<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CNN Interpretability Explorer</title>
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700;1,400;1,700&family=Inconsolata:wght@300;400;600;700&display=swap" rel="stylesheet">
<style>
:root {
  --ink:    #0e0c0a;
  --paper:  #f5f0e8;
  --paper2: #ede8dc;
  --paper3: #e4ddd0;
  --border: #c8bfae;
  --muted:  #8a8070;
  --dim:    #b8af9e;

  --s1: #c0392b;   /* latent — crimson */
  --s2: #1a5276;   /* filters — navy */
  --s3: #1e6b3c;   /* class model — forest */
  --s4: #6d3a8a;   /* saliency — plum */

  --s1l: #f9e5e3;
  --s2l: #ddeaf5;
  --s3l: #d9f0e3;
  --s4l: #ede0f5;
}

* { margin:0; padding:0; box-sizing:border-box; }

html { scroll-behavior: smooth; }

body {
  background: var(--paper);
  color: var(--ink);
  font-family: 'Inconsolata', monospace;
  overflow-x: hidden;
}

/* ── MASTHEAD ── */
.masthead {
  padding: 56px 64px 48px;
  border-bottom: 2px solid var(--ink);
  position: relative;
  overflow: hidden;
}

.masthead-bg {
  position: absolute;
  inset: 0;
  background:
    repeating-linear-gradient(0deg, transparent, transparent 39px, var(--border) 39px, var(--border) 40px),
    repeating-linear-gradient(90deg, transparent, transparent 39px, var(--border) 39px, var(--border) 40px);
  opacity: 0.18;
}

.masthead-inner { position: relative; z-index:1; }

.pub-info {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 32px;
}

.pub-tag {
  font-size: 8px;
  letter-spacing: 0.35em;
  text-transform: uppercase;
  color: var(--muted);
  line-height: 1.8;
}

.pub-tag span { color: var(--ink); font-weight: 600; }

.issue-num {
  font-family: 'Playfair Display', serif;
  font-size: 64px;
  color: var(--paper3);
  font-weight: 700;
  line-height:1;
}

h1 {
  font-family: 'Playfair Display', serif;
  font-size: clamp(36px, 6vw, 72px);
  font-weight: 700;
  line-height: 1.05;
  letter-spacing: -0.02em;
  margin-bottom: 12px;
  max-width: 700px;
}

h1 em {
  font-style: italic;
  color: var(--muted);
}

.masthead-sub {
  font-size: 11px;
  color: var(--muted);
  letter-spacing: 0.06em;
  line-height: 1.6;
  max-width: 500px;
  margin-bottom: 28px;
}

/* Tab nav */
.chapter-nav {
  display: flex;
  gap: 0;
  border: 1px solid var(--border);
  border-radius: 4px;
  overflow: hidden;
  width: fit-content;
}

.ch-tab {
  padding: 8px 18px;
  font-size: 8px;
  letter-spacing: 0.15em;
  text-transform: uppercase;
  font-weight: 600;
  cursor: pointer;
  border-right: 1px solid var(--border);
  transition: all 0.15s;
  white-space: nowrap;
  color: var(--muted);
  background: var(--paper);
}

.ch-tab:last-child { border-right: none; }
.ch-tab:hover:not(.active) { background: var(--paper2); color: var(--ink); }

.ch-tab.active { color: var(--paper); }
.ch-tab[data-ch="0"].active { background: var(--s1); }
.ch-tab[data-ch="1"].active { background: var(--s2); }
.ch-tab[data-ch="2"].active { background: var(--s3); }
.ch-tab[data-ch="3"].active { background: var(--s4); }

/* ── CHAPTER PANELS ── */
.chapters { min-height: calc(100vh - 280px); }

.chapter { display: none; }
.chapter.active { display: block; }

/* Chapter header strip */
.ch-header {
  display: flex;
  align-items: flex-end;
  justify-content: space-between;
  padding: 40px 64px 28px;
  border-bottom: 1px solid var(--border);
}

.ch-num {
  font-family: 'Playfair Display', serif;
  font-size: 96px;
  font-weight: 700;
  line-height: 0.85;
  color: var(--paper3);
  flex-shrink: 0;
  margin-right: 24px;
}

.ch-title-wrap { flex:1; }

.ch-label {
  font-size: 8px;
  letter-spacing: 0.3em;
  text-transform: uppercase;
  margin-bottom: 6px;
}

.ch-title {
  font-family: 'Playfair Display', serif;
  font-size: clamp(24px, 4vw, 42px);
  font-weight: 700;
  line-height: 1.1;
  letter-spacing: -0.01em;
}

.ch-title em { font-style: italic; }

.ch-desc {
  font-size: 10px;
  color: var(--muted);
  line-height: 1.7;
  max-width: 380px;
  text-align: right;
}

/* Content grid */
.ch-body {
  display: grid;
  grid-template-columns: 1fr 280px;
  min-height: calc(100vh - 420px);
}

.ch-main { padding: 36px 64px; border-right: 1px solid var(--border); }
.ch-aside { padding: 28px 24px; background: var(--paper2); display:flex; flex-direction:column; gap:20px; }

/* Canvas containers */
.canvas-box {
  border: 1px solid var(--border);
  border-radius: 3px;
  overflow: hidden;
  position: relative;
  background: var(--ink);
}

.canvas-box canvas { display:block; }

.canvas-tag {
  position: absolute;
  top: 8px; left: 10px;
  font-size: 7px;
  letter-spacing: 0.15em;
  text-transform: uppercase;
  color: var(--dim);
  background: rgba(14,12,10,0.7);
  padding: 3px 6px;
  border-radius: 2px;
}

/* Controls */
.ctrl-row {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  margin-bottom: 16px;
  align-items: center;
}

.ctrl-label {
  font-size: 8px;
  letter-spacing: 0.12em;
  text-transform: uppercase;
  color: var(--muted);
  margin-right: 4px;
}

.ctrl-btn {
  padding: 5px 12px;
  font-family: 'Inconsolata', monospace;
  font-size: 9px;
  letter-spacing: 0.06em;
  border: 1px solid var(--border);
  border-radius: 3px;
  background: var(--paper);
  color: var(--muted);
  cursor: pointer;
  transition: all 0.15s;
}

.ctrl-btn:hover { border-color: var(--ink); color: var(--ink); }
.ctrl-btn.active { background: var(--ink); color: var(--paper); border-color: var(--ink); }

input[type=range] {
  -webkit-appearance: none;
  height: 2px;
  background: var(--border);
  border-radius: 1px;
  outline: none;
  cursor: pointer;
}

input[type=range]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 12px; height: 12px;
  border-radius: 50%;
  background: var(--ink);
  cursor: pointer;
}

/* Aside components */
.aside-card {
  border: 1px solid var(--border);
  border-radius: 3px;
  overflow: hidden;
  background: var(--paper);
}

.aside-card-head {
  padding: 8px 12px;
  font-size: 7px;
  letter-spacing: 0.2em;
  text-transform: uppercase;
  color: var(--muted);
  border-bottom: 1px solid var(--border);
  background: var(--paper2);
}

.aside-card-body { padding: 12px; }

.note-row {
  display: flex;
  gap: 8px;
  align-items: flex-start;
  padding: 6px 0;
  border-bottom: 1px solid var(--border);
  font-size: 8.5px;
  line-height: 1.55;
}

.note-row:last-child { border-bottom: none; }

.note-dot {
  width: 5px; height: 5px;
  border-radius: 50%;
  flex-shrink:0;
  margin-top:5px;
}

.note-title { font-weight: 600; color: var(--ink); margin-bottom: 1px; display:block; }
.note-text { color: var(--muted); }

.kv-row {
  display: flex;
  justify-content: space-between;
  font-size: 9px;
  padding: 5px 0;
  border-bottom: 1px solid var(--border);
}

.kv-row:last-child { border-bottom:none; }
.kv-key { color: var(--muted); }
.kv-val { font-weight: 600; color: var(--ink); }

/* Tooltip */
#tip {
  position: fixed;
  background: var(--ink);
  color: var(--paper);
  border-radius: 4px;
  padding: 7px 11px;
  font-size: 9px;
  max-width: 200px;
  z-index:9999;
  opacity:0;
  transition: opacity 0.15s;
  pointer-events:none;
  line-height:1.5;
}

#tip.show { opacity:1; }
#tip strong { color: #f5c842; display:block; margin-bottom:2px; }

/* Animations */
@keyframes fadeUp {
  from { opacity:0; transform:translateY(10px); }
  to   { opacity:1; transform:none; }
}

.chapter.active .ch-header,
.chapter.active .ch-body { animation: fadeUp 0.35s ease both; }

/* ── LATENT: scatter + interpolation ── */
.latent-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 16px;
  margin-bottom: 16px;
}

/* ── FILTERS: grid ── */
.filter-grid {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  gap: 4px;
  margin-bottom: 16px;
}

.filter-cell {
  cursor: pointer;
  border: 2px solid transparent;
  border-radius: 3px;
  overflow: hidden;
  transition: border-color 0.15s, transform 0.15s;
}

.filter-cell:hover, .filter-cell.sel { border-color: var(--s2); transform:scale(1.06); z-index:3; }
.filter-cell canvas { display:block; width:100%; image-rendering:pixelated; }

/* ── CLASS MODEL: grid ── */
.class-grid {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  gap: 8px;
  margin-bottom: 16px;
}

.class-cell {
  cursor: pointer;
  border: 2px solid var(--border);
  border-radius: 4px;
  overflow: hidden;
  transition: all 0.15s;
  background: var(--ink);
}

.class-cell:hover, .class-cell.sel { border-color: var(--s3); transform: translateY(-3px); box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
.class-cell canvas { display:block; width:100%; image-rendering: pixelated; }
.class-cell-label {
  font-size: 7px;
  text-align: center;
  padding: 4px;
  background: var(--paper2);
  color: var(--muted);
  letter-spacing: 0.06em;
  text-transform: uppercase;
  border-top: 1px solid var(--border);
}

/* ── SALIENCY ── */
.saliency-row {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 10px;
  margin-bottom: 16px;
}

/* Footer */
footer {
  padding: 24px 64px;
  border-top: 2px solid var(--ink);
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 8px;
  letter-spacing: 0.1em;
  color: var(--muted);
  text-transform: uppercase;
}

@media (max-width: 800px) {
  .masthead, .ch-header, .ch-main, footer { padding-left: 20px; padding-right: 20px; }
  .ch-body { grid-template-columns: 1fr; }
  .ch-aside { border-top: 1px solid var(--border); }
  .latent-grid { grid-template-columns: 1fr; }
  .filter-grid { grid-template-columns: repeat(6,1fr); }
  .class-grid { grid-template-columns: repeat(3,1fr); }
  .saliency-row { grid-template-columns: repeat(2,1fr); }
  .ch-num { font-size: 56px; }
}
</style>
</head>
<body>
<div id="tip"></div>

<!-- ── MASTHEAD ── -->
<div class="masthead">
  <div class="masthead-bg"></div>
  <div class="masthead-inner">
    <div class="pub-info">
      <div class="pub-tag">
        UIUC · BIOE 486<br>
        <span>CNN Interpretability</span> · Interactive Visual Study
      </div>
      <div class="issue-num">IV</div>
    </div>
    <h1>Inside the<br><em>Black Box</em></h1>
    <p class="masthead-sub">Four techniques for visualizing and interpreting what convolutional neural networks learn: latent space geometry, filter patterns, class-optimal images, and input saliency.</p>
    <nav class="chapter-nav">
      <div class="ch-tab active" data-ch="0" onclick="goChapter(0,this)">I · Latent Codes</div>
      <div class="ch-tab" data-ch="1" onclick="goChapter(1,this)">II · Filters</div>
      <div class="ch-tab" data-ch="2" onclick="goChapter(2,this)">III · Class Models</div>
      <div class="ch-tab" data-ch="3" onclick="goChapter(3,this)">IV · Saliency Maps</div>
    </nav>
  </div>
</div>

<!-- ══════════════════════════════════════════
     CHAPTER 1 — LATENT CODES
══════════════════════════════════════════ -->
<div class="chapters">
<div class="chapter active" id="ch0">
  <div class="ch-header">
    <div class="ch-num" style="color:var(--s1l)">I</div>
    <div class="ch-title-wrap">
      <div class="ch-label" style="color:var(--s1)">Representation Learning</div>
      <div class="ch-title">Latent <em>Codes</em></div>
    </div>
    <p class="ch-desc">The penultimate layer of a CNN compresses every input into a dense vector — the latent code. Visualizing this space reveals how the network organizes the world.</p>
  </div>

  <div class="ch-body">
    <div class="ch-main">

      <!-- Controls -->
      <div class="ctrl-row">
        <span class="ctrl-label">Projection:</span>
        <button class="ctrl-btn active" onclick="setLatentMode('tsne',this)">t-SNE</button>
        <button class="ctrl-btn" onclick="setLatentMode('umap',this)">UMAP</button>
        <button class="ctrl-btn" onclick="setLatentMode('pca',this)">PCA</button>
        <span class="ctrl-label" style="margin-left:12px">Classes:</span>
        <button class="ctrl-btn active" id="btnAll" onclick="toggleAllClasses(this)">All</button>
      </div>

      <!-- Class filter pills -->
      <div class="ctrl-row" id="classPills" style="margin-bottom:20px;"></div>

      <!-- Latent scatter -->
      <div class="latent-grid">
        <div class="canvas-box" style="border-color:var(--border)">
          <div class="canvas-tag">Latent Space</div>
          <canvas id="latentScatter" width="420" height="340"></canvas>
        </div>
        <div class="canvas-box">
          <div class="canvas-tag">Interpolation Path</div>
          <canvas id="latentInterp" width="420" height="340"></canvas>
        </div>
      </div>

      <!-- Interpolation controls -->
      <div style="margin-bottom:20px;padding:14px 16px;background:var(--paper2);border:1px solid var(--border);border-radius:3px;">
        <div class="ctrl-row" style="margin-bottom:8px;">
          <span class="ctrl-label">Interpolate: A</span>
          <select id="interpA" onchange="drawInterp()" style="font-family:'Inconsolata',monospace;font-size:9px;padding:4px 8px;border:1px solid var(--border);background:var(--paper);border-radius:3px;color:var(--ink);">
          </select>
          <span class="ctrl-label">→ B</span>
          <select id="interpB" onchange="drawInterp()" style="font-family:'Inconsolata',monospace;font-size:9px;padding:4px 8px;border:1px solid var(--border);background:var(--paper);border-radius:3px;color:var(--ink);">
          </select>
        </div>
        <div style="display:flex;align-items:center;gap:10px;">
          <span class="ctrl-label" style="white-space:nowrap;">α =</span>
          <input type="range" id="interpAlpha" min="0" max="100" value="50" oninput="drawInterpSlider()" style="flex:1">
          <span id="alphaVal" style="font-size:9px;color:var(--muted);width:28px;">0.50</span>
        </div>
      </div>

      <!-- Interpolation strip -->
      <div style="display:flex;gap:4px;align-items:center;margin-bottom:4px;">
        <span style="font-size:8px;color:var(--muted);letter-spacing:0.1em;text-transform:uppercase;width:60px;">A (α=0)</span>
        <div id="interpStrip" style="flex:1;display:flex;gap:3px;"></div>
        <span style="font-size:8px;color:var(--muted);letter-spacing:0.1em;text-transform:uppercase;width:60px;text-align:right;">B (α=1)</span>
      </div>
      <div style="font-size:8px;color:var(--muted);margin-top:4px;">Smooth interpolation through latent space between two class centroids</div>
    </div>

    <div class="ch-aside">
      <div class="aside-card">
        <div class="aside-card-head">What is a Latent Code?</div>
        <div class="aside-card-body">
          <div class="note-row">
            <div class="note-dot" style="background:var(--s1)"></div>
            <div><span class="note-title">Definition</span><span class="note-text">The activation vector z ∈ ℝᵈ output by the last hidden layer before classification. d is typically 512–4096.</span></div>
          </div>
          <div class="note-row">
            <div class="note-dot" style="background:var(--s1)"></div>
            <div><span class="note-title">Cluster separation</span><span class="note-text">Well-separated clusters indicate the network has learned linearly separable representations.</span></div>
          </div>
          <div class="note-row">
            <div class="note-dot" style="background:var(--s1)"></div>
            <div><span class="note-title">Interpolation</span><span class="note-text">z_α = (1−α)·z_A + α·z_B. Smooth paths indicate a continuous, structured manifold.</span></div>
          </div>
          <div class="note-row">
            <div class="note-dot" style="background:var(--s1)"></div>
            <div><span class="note-title">Collapse / entanglement</span><span class="note-text">Overlapping clusters signal confused representations — often under-trained or domain-shifted.</span></div>
          </div>
        </div>
      </div>

      <div class="aside-card">
        <div class="aside-card-head">Projection Methods</div>
        <div class="aside-card-body">
          <div class="kv-row"><span class="kv-key">t-SNE</span><span class="kv-val" style="color:var(--s1)">Local clusters</span></div>
          <div class="kv-row"><span class="kv-key">UMAP</span><span class="kv-val" style="color:var(--s2)">Global + local</span></div>
          <div class="kv-row"><span class="kv-key">PCA</span><span class="kv-val" style="color:var(--s3)">Linear variance</span></div>
          <div class="kv-row"><span class="kv-key">Feature dim</span><span class="kv-val">2048D → 2D</span></div>
          <div class="kv-row"><span class="kv-key">Points shown</span><span class="kv-val">400</span></div>
        </div>
      </div>

      <div class="aside-card">
        <div class="aside-card-head">Hover / Click</div>
        <div class="aside-card-body">
          <div style="font-size:8.5px;color:var(--muted);line-height:1.6;">
            Hover a point on the scatter to see its class label. Click to highlight the full class cluster. Use class pills above to filter.
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- ══════════════════════════════════════════
     CHAPTER 2 — FILTER VISUALIZATION
══════════════════════════════════════════ -->
<div class="chapter" id="ch1">
  <div class="ch-header">
    <div class="ch-num" style="color:var(--s2l)">II</div>
    <div class="ch-title-wrap">
      <div class="ch-label" style="color:var(--s2)">Learned Patterns</div>
      <div class="ch-title">Filter <em>Visualization</em></div>
    </div>
    <p class="ch-desc">Each convolutional filter is a learned feature detector. We can visualize what pattern maximally activates it via optimization in input space.</p>
  </div>

  <div class="ch-body">
    <div class="ch-main">
      <div class="ctrl-row">
        <span class="ctrl-label">Layer:</span>
        <button class="ctrl-btn active" onclick="setFilterLayer('conv1',this)">Conv1 · 3×3</button>
        <button class="ctrl-btn" onclick="setFilterLayer('conv2',this)">Conv2 · 3×3</button>
        <button class="ctrl-btn" onclick="setFilterLayer('conv3',this)">Conv3 · 3×3</button>
        <button class="ctrl-btn" onclick="setFilterLayer('conv4',this)">Conv4 · 3×3</button>
      </div>
      <div class="ctrl-row" style="margin-bottom:20px;">
        <span class="ctrl-label">Style:</span>
        <button class="ctrl-btn active" onclick="setFilterStyle('freq',this)">Frequency</button>
        <button class="ctrl-btn" onclick="setFilterStyle('spatial',this)">Spatial</button>
        <button class="ctrl-btn" onclick="setFilterStyle('color',this)">Color tuning</button>
      </div>

      <div class="filter-grid" id="filterGrid"></div>

      <!-- Detail panel -->
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;">
        <div class="canvas-box">
          <div class="canvas-tag">Selected Filter (×16 zoom)</div>
          <canvas id="filterDetail" width="280" height="280"></canvas>
        </div>
        <div class="canvas-box">
          <div class="canvas-tag">Activation Response</div>
          <canvas id="filterResponse" width="280" height="280"></canvas>
        </div>
      </div>
    </div>

    <div class="ch-aside">
      <div class="aside-card">
        <div class="aside-card-head">What are Filters?</div>
        <div class="aside-card-body">
          <div class="note-row">
            <div class="note-dot" style="background:var(--s2)"></div>
            <div><span class="note-title">Learned detectors</span><span class="note-text">Each filter W ∈ ℝ^(k×k×C_in) is a pattern template learned end-to-end by gradient descent.</span></div>
          </div>
          <div class="note-row">
            <div class="note-dot" style="background:var(--s2)"></div>
            <div><span class="note-title">Activation maximization</span><span class="note-text">Synthesize input x* = argmax f_l(x) by gradient ascent — reveals the ideal stimulus.</span></div>
          </div>
          <div class="note-row">
            <div class="note-dot" style="background:var(--s2)"></div>
            <div><span class="note-title">Early → late depth</span><span class="note-text">Early filters: Gabor-like edges, colors. Deep filters: textures, object parts, semantic concepts.</span></div>
          </div>
          <div class="note-row">
            <div class="note-dot" style="background:var(--s2)"></div>
            <div><span class="note-title">Dead filters</span><span class="note-text">Uniform/noisy filters indicate under-training, poor init, or excessive regularization.</span></div>
          </div>
        </div>
      </div>

      <div class="aside-card">
        <div class="aside-card-head">Layer Characteristics</div>
        <div class="aside-card-body">
          <div class="kv-row"><span class="kv-key">Conv1</span><span class="kv-val" style="color:var(--s2)">Edges, orientations</span></div>
          <div class="kv-row"><span class="kv-key">Conv2</span><span class="kv-val" style="color:var(--s2)">Textures, corners</span></div>
          <div class="kv-row"><span class="kv-key">Conv3</span><span class="kv-val" style="color:var(--s2)">Motifs, patterns</span></div>
          <div class="kv-row"><span class="kv-key">Conv4</span><span class="kv-val" style="color:var(--s2)">Object parts</span></div>
          <div class="kv-row"><span class="kv-key">Receptive field</span><span class="kv-val">grows with depth</span></div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- ══════════════════════════════════════════
     CHAPTER 3 — CLASS MODEL VISUALIZATION
══════════════════════════════════════════ -->
<div class="chapter" id="ch2">
  <div class="ch-header">
    <div class="ch-num" style="color:var(--s3l)">III</div>
    <div class="ch-title-wrap">
      <div class="ch-label" style="color:var(--s3)">Gradient Ascent</div>
      <div class="ch-title">Class Model <em>Visualization</em></div>
    </div>
    <p class="ch-desc">Generate the "dream image" for each class by maximizing the class score with respect to input pixels. Shows what the network thinks a class looks like.</p>
  </div>

  <div class="ch-body">
    <div class="ch-main">
      <div class="ctrl-row" style="margin-bottom:20px;">
        <span class="ctrl-label">Regularization:</span>
        <button class="ctrl-btn active" onclick="setClassReg('l2',this)">L2 decay</button>
        <button class="ctrl-btn" onclick="setClassReg('tv',this)">TV smooth</button>
        <button class="ctrl-btn" onclick="setClassReg('deep',this)">Deep Dream</button>
        <span class="ctrl-label" style="margin-left:12px">Iterations:</span>
        <input type="range" id="iterSlider" min="50" max="500" value="200" oninput="updateIterLabel(this)" style="width:80px">
        <span id="iterLabel" style="font-size:9px;color:var(--muted);width:36px;">200</span>
      </div>

      <div class="class-grid" id="classGrid"></div>

      <!-- Selected class detail -->
      <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px;">
        <div class="canvas-box">
          <div class="canvas-tag">Class model (selected)</div>
          <canvas id="classDetail" width="240" height="240"></canvas>
        </div>
        <div class="canvas-box">
          <div class="canvas-tag">Frequency spectrum</div>
          <canvas id="classSpectrum" width="240" height="240"></canvas>
        </div>
        <div class="canvas-box">
          <div class="canvas-tag">Octave decomposition</div>
          <canvas id="classOctave" width="240" height="240"></canvas>
        </div>
      </div>
    </div>

    <div class="ch-aside">
      <div class="aside-card">
        <div class="aside-card-head">How it works</div>
        <div class="aside-card-body">
          <div class="note-row">
            <div class="note-dot" style="background:var(--s3)"></div>
            <div><span class="note-title">Objective</span><span class="note-text">x* = argmax_x S_c(x) − λ·R(x) where S_c is class score and R is a regularizer.</span></div>
          </div>
          <div class="note-row">
            <div class="note-dot" style="background:var(--s3)"></div>
            <div><span class="note-title">L2 regularization</span><span class="note-text">Penalizes large pixel values. Produces smooth, globally coherent patterns.</span></div>
          </div>
          <div class="note-row">
            <div class="note-dot" style="background:var(--s3)"></div>
            <div><span class="note-title">Total variation</span><span class="note-text">Penalizes pixel-to-pixel variation. Produces piecewise smooth images.</span></div>
          </div>
          <div class="note-row">
            <div class="note-dot" style="background:var(--s3)"></div>
            <div><span class="note-title">Deep Dream</span><span class="note-text">Amplify existing patterns without strong regularization. Creates surreal textures.</span></div>
          </div>
        </div>
      </div>
      <div class="aside-card">
        <div class="aside-card-head">Interpretation</div>
        <div class="aside-card-body">
          <div style="font-size:8.5px;color:var(--muted);line-height:1.65;">
            Class models reveal <strong style="color:var(--ink)">what features</strong> define a class in the network's view. High-frequency noise indicates texture bias; semantic shapes indicate shape bias. Click a class thumbnail to view details.
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- ══════════════════════════════════════════
     CHAPTER 4 — SALIENCY MAPS
══════════════════════════════════════════ -->
<div class="chapter" id="ch3">
  <div class="ch-header">
    <div class="ch-num" style="color:var(--s4l)">IV</div>
    <div class="ch-title-wrap">
      <div class="ch-label" style="color:var(--s4)">Attribution Methods</div>
      <div class="ch-title">Saliency <em>Maps</em></div>
    </div>
    <p class="ch-desc">Which input pixels contributed most to the prediction? Multiple attribution methods reveal different aspects of the network's decision process.</p>
  </div>

  <div class="ch-body">
    <div class="ch-main">
      <div class="ctrl-row" style="margin-bottom:8px;">
        <span class="ctrl-label">Input Image:</span>
        <button class="ctrl-btn active" onclick="selectSaliencyInput(0,this)">Nodule CT</button>
        <button class="ctrl-btn" onclick="selectSaliencyInput(1,this)">Edge Grid</button>
        <button class="ctrl-btn" onclick="selectSaliencyInput(2,this)">Circle</button>
        <button class="ctrl-btn" onclick="selectSaliencyInput(3,this)">Texture</button>
      </div>
      <div class="ctrl-row" style="margin-bottom:20px;">
        <span class="ctrl-label">Overlay α:</span>
        <input type="range" id="saliencyAlpha" min="0" max="100" value="65" oninput="redrawSaliency()" style="width:100px">
        <span class="ctrl-label" style="margin-left:8px;">Smooth σ:</span>
        <input type="range" id="saliencySigma" min="0" max="10" value="2" oninput="redrawSaliency()" style="width:80px">
      </div>

      <!-- 4-method comparison -->
      <div class="saliency-row" id="saliencyRow"></div>

      <!-- Detail -->
      <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:10px;">
        <div class="canvas-box">
          <div class="canvas-tag">Vanilla Grad</div>
          <canvas id="sal0" width="180" height="180"></canvas>
        </div>
        <div class="canvas-box">
          <div class="canvas-tag">Smooth Grad</div>
          <canvas id="sal1" width="180" height="180"></canvas>
        </div>
        <div class="canvas-box">
          <div class="canvas-tag">Grad × Input</div>
          <canvas id="sal2" width="180" height="180"></canvas>
        </div>
        <div class="canvas-box">
          <div class="canvas-tag">GradCAM</div>
          <canvas id="sal3" width="180" height="180"></canvas>
        </div>
      </div>
    </div>

    <div class="ch-aside">
      <div class="aside-card">
        <div class="aside-card-head">Attribution Methods</div>
        <div class="aside-card-body">
          <div class="note-row">
            <div class="note-dot" style="background:var(--s4)"></div>
            <div><span class="note-title">Vanilla Gradient</span><span class="note-text">∂S_c/∂x — gradient of class score w.r.t. each pixel. Fast but noisy.</span></div>
          </div>
          <div class="note-row">
            <div class="note-dot" style="background:var(--s4)"></div>
            <div><span class="note-title">SmoothGrad</span><span class="note-text">Average over N noisy copies of input: 1/N Σ ∂S(x+ε)/∂x. Reduces noise.</span></div>
          </div>
          <div class="note-row">
            <div class="note-dot" style="background:var(--s4)"></div>
            <div><span class="note-title">Grad × Input</span><span class="note-text">x ⊙ ∂S_c/∂x — element-wise product highlights relevant high-magnitude pixels.</span></div>
          </div>
          <div class="note-row">
            <div class="note-dot" style="background:var(--s4)"></div>
            <div><span class="note-title">GradCAM</span><span class="note-text">Weights final conv feature maps by class-specific gradient averages. Class-discriminative and spatial.</span></div>
          </div>
        </div>
      </div>
      <div class="aside-card">
        <div class="aside-card-head">Comparison</div>
        <div class="aside-card-body">
          <div class="kv-row"><span class="kv-key">Vanilla Grad</span><span class="kv-val" style="color:var(--s4)">Noisy, fine-grained</span></div>
          <div class="kv-row"><span class="kv-key">SmoothGrad</span><span class="kv-val" style="color:var(--s4)">Denoised, stable</span></div>
          <div class="kv-row"><span class="kv-key">Grad×Input</span><span class="kv-val" style="color:var(--s4)">Sharp, localized</span></div>
          <div class="kv-row"><span class="kv-key">GradCAM</span><span class="kv-val" style="color:var(--s4)">Coarse, class-specific</span></div>
          <div class="kv-row"><span class="kv-key">Resolution</span><span class="kv-val">pixel → region</span></div>
        </div>
      </div>
    </div>
  </div>
</div>
</div><!-- /chapters -->

<footer>
  <span>BIOE 486 · Deep Learning Visual Study</span>
  <span>CNN Interpretability · Hover for details</span>
</footer>

<script>
// ══════════════ UTILS ══════════════
const clamp = (v,lo=0,hi=1) => Math.max(lo,Math.min(hi,v));
const lerp  = (a,b,t) => a+(b-a)*t;

function seeded(s) {
  return function() { s=(s*16807)%2147483647; return (s-1)/2147483646; };
}

const tip = document.getElementById('tip');
function showTip(e, title, body) {
  tip.innerHTML = `<strong>${title}</strong>${body}`;
  tip.classList.add('show');
}
function hideTip() { tip.classList.remove('show'); }
document.addEventListener('mousemove', e => {
  if(!tip.classList.contains('show')) return;
  let x=e.clientX+14, y=e.clientY+14;
  if(x+210>window.innerWidth) x=e.clientX-215;
  if(y+80>window.innerHeight) y=e.clientY-80;
  tip.style.left=x+'px'; tip.style.top=y+'px';
});

// Colormaps
function viridis(t) {
  const r=clamp(lerp3(0.267,0.127,0.993,t));
  const g=clamp(lerp3(0.005,0.566,0.906,t));
  const b=clamp(lerp3(0.329,0.551,0.144,t));
  return [Math.round(r*255),Math.round(g*255),Math.round(b*255)];
}
function plasma(t) {
  const r=clamp(0.05+t*1.014+t*t*(-0.326));
  const g=clamp(0.03+t*(-0.152)+t*t*1.246);
  const b=clamp(0.528+t*0.432+t*t*(-0.923));
  return [Math.round(r*255),Math.round(g*255),Math.round(b*255)];
}
function hot(t) {
  return [Math.round(clamp(t*3)*255), Math.round(clamp(t*3-1)*255), Math.round(clamp(t*3-2)*255)];
}
function diverge(t) { // blue-white-red
  if(t<0.5){ const s=t*2; return [Math.round(lerp(50,255,s)), Math.round(lerp(100,255,s)), Math.round(lerp(200,255,s))]; }
  const s=(t-0.5)*2;
  return [Math.round(lerp(255,200,s)), Math.round(lerp(255,50,s)), Math.round(lerp(255,50,s))];
}
function lerp3(a,b,c,t){ return t<0.5?lerp(a,b,t*2):lerp(b,c,(t-0.5)*2); }

// ══════════════ CHAPTER SWITCHING ══════════════
function goChapter(idx, el) {
  document.querySelectorAll('.chapter').forEach((c,i) => c.classList.toggle('active',i===idx));
  document.querySelectorAll('.ch-tab').forEach(t => t.classList.remove('active'));
  el.classList.add('active');
}

// ══════════════════════════════════════════════════
// CHAPTER 1 — LATENT CODES
// ══════════════════════════════════════════════════
const classNames = ['Adenocarcinoma','Squamous Cell','Small Cell','Benign Nodule','Normal Lung','Ground Glass','Consolidation','Effusion','Pneumothorax','Emphysema'];
const classColors = ['#c0392b','#1a5276','#1e6b3c','#d4891a','#6d3a8a','#2980b9','#8e44ad','#16a085','#c0392b','#7f8c8d'];
const classPillColors = ['#c0392b','#1a5276','#1e6b3c','#d4891a','#6d3a8a','#2980b9','#8e44ad','#16a085','#e74c3c','#95a5a6'];

let latentMode = 'tsne';
let activeClasses = new Set(classNames.map((_,i)=>i));
let latentPoints = [];

function genLatentPoints() {
  const r = seeded(42);
  const pts = [];
  const centers_tsne = [
    [0.15,0.20],[0.75,0.15],[0.80,0.80],[0.20,0.75],[0.50,0.50],
    [0.30,0.55],[0.65,0.40],[0.10,0.60],[0.85,0.50],[0.45,0.85]
  ];
  const centers_umap = [
    [0.12,0.18],[0.70,0.12],[0.82,0.82],[0.18,0.72],[0.48,0.52],
    [0.35,0.60],[0.62,0.35],[0.08,0.55],[0.88,0.48],[0.42,0.88]
  ];
  const centers_pca = [
    [0.1,0.9],[0.3,0.7],[0.5,0.5],[0.7,0.3],[0.9,0.1],
    [0.2,0.6],[0.4,0.8],[0.6,0.4],[0.8,0.2],[0.5,0.7]
  ];
  classNames.forEach((name,ci) => {
    const n = 30 + Math.floor(r()*20);
    for(let i=0;i<n;i++) {
      const ct = centers_tsne[ci], cu=centers_umap[ci], cp=centers_pca[ci];
      const spread = 0.06+r()*0.04;
      const angle = r()*Math.PI*2, d=r()*spread;
      pts.push({
        ci, name,
        tsne: [ct[0]+Math.cos(angle)*d, ct[1]+Math.sin(angle)*d],
        umap: [cu[0]+Math.cos(angle)*d*1.1, cu[1]+Math.sin(angle)*d*0.9],
        pca:  [cp[0]+Math.cos(angle)*d*1.3, cp[1]+Math.sin(angle)*d*0.7+(i/n)*0.05],
      });
    }
  });
  return pts;
}

function drawLatentScatter() {
  const c = document.getElementById('latentScatter');
  const ctx = c.getContext('2d');
  const W=c.width, H=c.height;
  ctx.fillStyle='#0e0c0a';
  ctx.fillRect(0,0,W,H);

  // Grid
  ctx.strokeStyle='rgba(255,255,255,0.04)';
  ctx.lineWidth=1;
  for(let i=0;i<=4;i++) {
    ctx.beginPath(); ctx.moveTo(i*W/4,0); ctx.lineTo(i*W/4,H); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,i*H/4); ctx.lineTo(W,i*H/4); ctx.stroke();
  }

  // Convex hull blobs per class (ellipses)
  classNames.forEach((name,ci) => {
    if(!activeClasses.has(ci)) return;
    const pts2 = latentPoints.filter(p=>p.ci===ci);
    let xs=pts2.map(p=>p[latentMode][0]*W), ys=pts2.map(p=>p[latentMode][1]*H);
    const mx=xs.reduce((a,b)=>a+b,0)/xs.length, my=ys.reduce((a,b)=>a+b,0)/ys.length;
    const sx=Math.sqrt(xs.reduce((a,b)=>a+(b-mx)**2,0)/xs.length);
    const sy=Math.sqrt(ys.reduce((a,b)=>a+(b-my)**2,0)/ys.length);
    ctx.save();
    ctx.globalAlpha=0.07;
    ctx.fillStyle=classPillColors[ci];
    ctx.beginPath();
    ctx.ellipse(mx,my,sx*1.8,sy*1.8,0,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  });

  // Points
  latentPoints.forEach(p => {
    if(!activeClasses.has(p.ci)) return;
    const [px,py] = p[latentMode];
    const x=px*W, y=py*H;
    ctx.beginPath();
    ctx.arc(x,y,3.5,0,Math.PI*2);
    ctx.fillStyle=classPillColors[p.ci];
    ctx.globalAlpha=0.75;
    ctx.fill();
    ctx.globalAlpha=1;
  });

  // Axis labels
  ctx.fillStyle='rgba(255,255,255,0.15)';
  ctx.font='8px Inconsolata';
  ctx.fillText(latentMode.toUpperCase()+'₁', W-50, H-6);
  ctx.save(); ctx.translate(10,50); ctx.rotate(-Math.PI/2);
  ctx.fillText(latentMode.toUpperCase()+'₂',0,0);
  ctx.restore();
}

function buildClassPills() {
  const wrap = document.getElementById('classPills');
  wrap.innerHTML='';
  classNames.forEach((name,ci) => {
    const btn = document.createElement('button');
    btn.className='ctrl-btn active';
    btn.textContent=name.split(' ')[0];
    btn.style.borderColor=classPillColors[ci];
    btn.style.color=classPillColors[ci];
    btn.onclick=()=>{
      if(activeClasses.has(ci)){activeClasses.delete(ci);btn.classList.remove('active');btn.style.background='';}
      else{activeClasses.add(ci);btn.classList.add('active');btn.style.background=classPillColors[ci]+'22';}
      drawLatentScatter();
    };
    btn.style.background=classPillColors[ci]+'22';
    wrap.appendChild(btn);
  });
}

function buildInterpSelects() {
  const sa=document.getElementById('interpA'), sb=document.getElementById('interpB');
  classNames.forEach((n,i)=>{ sa.add(new Option(n,i)); sb.add(new Option(n,i)); });
  sb.value=1;
}

function drawInterp() {
  const a=+document.getElementById('interpA').value;
  const b=+document.getElementById('interpB').value;
  const alpha=+document.getElementById('interpAlpha').value/100;
  document.getElementById('alphaVal').textContent=alpha.toFixed(2);

  // Get centroids
  const ptA=latentPoints.filter(p=>p.ci===a), ptB=latentPoints.filter(p=>p.ci===b);
  const cA=[ptA.reduce((s,p)=>s+p[latentMode][0],0)/ptA.length, ptA.reduce((s,p)=>s+p[latentMode][1],0)/ptA.length];
  const cB=[ptB.reduce((s,p)=>s+p[latentMode][0],0)/ptB.length, ptB.reduce((s,p)=>s+p[latentMode][1],0)/ptB.length];

  const c=document.getElementById('latentInterp');
  const ctx=c.getContext('2d');
  const W=c.width,H=c.height;
  ctx.fillStyle='#0e0c0a'; ctx.fillRect(0,0,W,H);

  // Draw all points faded
  latentPoints.forEach(p=>{
    const [px,py]=p[latentMode];
    ctx.beginPath(); ctx.arc(px*W,py*H,2.5,0,Math.PI*2);
    ctx.fillStyle=classPillColors[p.ci];
    ctx.globalAlpha=0.15; ctx.fill(); ctx.globalAlpha=1;
  });

  // Interpolation path
  const steps=12;
  ctx.setLineDash([4,4]);
  ctx.strokeStyle='rgba(255,255,255,0.2)';
  ctx.lineWidth=1;
  ctx.beginPath();
  ctx.moveTo(cA[0]*W,cA[1]*H);
  ctx.lineTo(cB[0]*W,cB[1]*H);
  ctx.stroke();
  ctx.setLineDash([]);

  // Moving point
  const mx=lerp(cA[0],cB[0],alpha)*W, my=lerp(cA[1],cB[1],alpha)*H;
  const col=`hsl(${lerp(0,220,alpha)},70%,55%)`;
  ctx.beginPath(); ctx.arc(mx,my,7,0,Math.PI*2);
  ctx.fillStyle=col; ctx.fill();
  ctx.strokeStyle='white'; ctx.lineWidth=1.5; ctx.stroke();

  // Step dots
  for(let i=0;i<=steps;i++){
    const t=i/steps;
    const x=lerp(cA[0],cB[0],t)*W, y=lerp(cA[1],cB[1],t)*H;
    ctx.beginPath(); ctx.arc(x,y,3,0,Math.PI*2);
    ctx.fillStyle=`hsl(${lerp(0,220,t)},70%,55%)`; ctx.fill();
  }

  // Centroid highlights
  [[cA,classPillColors[a]],[cB,classPillColors[b]]].forEach(([c,col])=>{
    ctx.beginPath(); ctx.arc(c[0]*W,c[1]*H,8,0,Math.PI*2);
    ctx.strokeStyle=col; ctx.lineWidth=2; ctx.stroke();
    ctx.fillStyle=col+'44'; ctx.fill();
  });

  // Labels
  ctx.fillStyle='rgba(255,255,255,0.5)'; ctx.font='8px Inconsolata';
  ctx.fillText(classNames[a].slice(0,10), cA[0]*W+10, cA[1]*H+4);
  ctx.fillText(classNames[b].slice(0,10), cB[0]*W+10, cB[1]*H+4);
  ctx.fillText('α='+alpha.toFixed(2), mx+10, my-4);

  drawInterpStrip(a,b,alpha);
}

function drawInterpStrip(a, b, alpha) {
  const strip = document.getElementById('interpStrip');
  strip.innerHTML='';
  const steps=8;
  for(let i=0;i<=steps;i++){
    const t=i/steps;
    const cv=document.createElement('canvas');
    cv.width=40; cv.height=40;
    cv.style.width='100%'; cv.style.height='auto'; cv.style.imageRendering='pixelated';
    cv.style.borderRadius='3px';
    cv.style.border=Math.abs(t-alpha)<0.07?'2px solid '+`hsl(${lerp(0,220,t)},70%,55%)`:'1px solid rgba(200,191,174,0.3)';
    const ctx=cv.getContext('2d');
    // Synthesize blended pattern
    const r=seeded(a*100+b*10+Math.round(t*100));
    const img=ctx.createImageData(40,40);
    const colA=[...classPillColors[a].match(/[\da-f]{2}/gi).map(h=>parseInt(h,16))];
    const colB=[...classPillColors[b].match(/[\da-f]{2}/gi).map(h=>parseInt(h,16))];
    for(let y=0;y<40;y++) for(let x=0;x<40;x++) {
      const angle=(x+y)*0.15+t*3;
      const v=Math.sin(angle+(a-b)*0.5)*0.5+0.5;
      const noise=r()*0.15;
      const blend=clamp(v*t+(1-t)*(1-v)+noise);
      const ri=lerp(colA[0],colB[0],t+noise);
      const gi=lerp(colA[1],colB[1],t-noise);
      const bi=lerp(colA[2],colB[2],t);
      const k=(y*40+x)*4;
      img.data[k]=Math.round(ri*0.4+10); img.data[k+1]=Math.round(gi*0.4+10);
      img.data[k+2]=Math.round(bi*0.4+10); img.data[k+3]=255;
    }
    ctx.putImageData(img,0,0);
    strip.appendChild(cv);
  }
}

function drawInterpSlider() {
  const alpha=+document.getElementById('interpAlpha').value/100;
  document.getElementById('alphaVal').textContent=alpha.toFixed(2);
  drawInterp();
}

function setLatentMode(mode, btn) {
  latentMode=mode;
  document.querySelectorAll('#ch0 .ctrl-btn').forEach(b=>{if(['tsne','umap','pca'].some(m=>b.textContent.toLowerCase().includes(m)))b.classList.remove('active');});
  btn.classList.add('active');
  drawLatentScatter();
  drawInterp();
}

// ══════════════════════════════════════════════════
// CHAPTER 2 — FILTER VISUALIZATION
// ══════════════════════════════════════════════════
let filterLayer='conv1', filterStyle='freq';
let selectedFilter=0;

const filterFns = {
  freq: [
    (x,y,W,H,p)=>Math.sin(x/W*Math.PI*(2+p*6)),
    (x,y,W,H,p)=>Math.cos(y/H*Math.PI*(2+p*6)),
    (x,y,W,H,p)=>Math.sin((x+y)/(W+H)*Math.PI*(4+p*8)),
    (x,y,W,H,p)=>Math.sin(x/W*Math.PI*3)*Math.cos(y/H*Math.PI*3),
    (x,y,W,H,p)=>Math.sin(x/W*Math.PI*(1+p*4))*Math.sin(y/H*Math.PI*(1+p*4)),
    (x,y,W,H,p)=>Math.cos((x-W/2)/W*Math.PI*(4+p*4)),
    (x,y,W,H,p)=>Math.sin(Math.sqrt((x-W/2)**2+(y-H/2)**2)/W*Math.PI*(3+p*6)),
    (x,y,W,H,p)=>Math.sin(x/W*Math.PI*8+p)*Math.cos(y/H*Math.PI*4),
  ],
  spatial: [
    (x,y,W,H,p)=>x/W,
    (x,y,W,H,p)=>y/H,
    (x,y,W,H,p)=>1-Math.sqrt((x/W-0.5)**2+(y/H-0.5)**2)*2,
    (x,y,W,H,p)=>(Math.abs(x/W-0.5)+Math.abs(y/H-0.5)),
    (x,y,W,H,p)=>Math.max(Math.abs(x/W-0.5),Math.abs(y/H-0.5)),
    (x,y,W,H,p)=>((x+y)%(W/4))/W*4,
    (x,y,W,H,p)=>Math.atan2(y-H/2,x-W/2)/Math.PI/2+0.5,
    (x,y,W,H,p)=>Math.abs(Math.sin(x/W*Math.PI*2)*Math.sin(y/H*Math.PI*2)),
  ],
  color: [
    (x,y,W,H,p)=>Math.sin(x/W*Math.PI*2+p),
    (x,y,W,H,p)=>Math.cos(y/H*Math.PI*2+p),
    (x,y,W,H,p)=>(Math.sin(x/W*4+p)+Math.cos(y/H*4))/2,
    (x,y,W,H,p)=>Math.sin(Math.sqrt((x-W/2)**2+(y-H/2)**2)*0.1+p),
    (x,y,W,H,p)=>Math.abs(Math.sin(x/W*8+p*2)),
    (x,y,W,H,p)=>clamp((x-W/2)/(W/2)*p+0.5),
    (x,y,W,H,p)=>Math.sin(x/W*Math.PI*6)*0.5+0.5,
    (x,y,W,H,p)=>clamp(Math.cos(y/H*Math.PI*6)*0.5+0.5),
  ],
};

const layerComplexity={'conv1':1,'conv2':1.8,'conv3':2.8,'conv4':4};
const filterCMs=['viridis','plasma','hot','viridis'];

function renderFilterCanvas(cv, fi, W=40, H=40) {
  const ctx=cv.getContext('2d');
  cv.width=W; cv.height=H;
  const img=ctx.createImageData(W,H);
  const fns=filterFns[filterStyle];
  const fn=fns[fi%fns.length];
  const r=seeded(fi*17+layerComplexity[filterLayer]*100);
  const phase=r()*Math.PI*2;
  const cmFns=[viridis,plasma,hot,diverge];
  const cm=cmFns[fi%cmFns.length];
  const complexity=layerComplexity[filterLayer];
  for(let y=0;y<H;y++) for(let x=0;x<W;x++){
    const raw=fn(x,y,W,H,phase)*complexity*0.5;
    const t=clamp(raw*0.5+0.5+(r()-0.5)*0.05);
    const [rv,gv,bv]=cm(t);
    const k=(y*W+x)*4;
    img.data[k]=rv; img.data[k+1]=gv; img.data[k+2]=bv; img.data[k+3]=255;
  }
  ctx.putImageData(img,0,0);
}

function buildFilterGrid() {
  const grid=document.getElementById('filterGrid');
  grid.innerHTML='';
  const n={'conv1':8,'conv2':16,'conv3':32,'conv4':32}[filterLayer];
  for(let i=0;i<n;i++){
    const cell=document.createElement('div');
    cell.className='filter-cell'+(i===selectedFilter?' sel':'');
    const cv=document.createElement('canvas');
    renderFilterCanvas(cv,i);
    cell.appendChild(cv);
    cell.addEventListener('mouseenter',e=>showTip(e,`Filter ${i} · ${filterLayer}`,`Layer: ${filterLayer}<br>Style: ${filterStyle}<br>Complexity ×${layerComplexity[filterLayer]}`));
    cell.addEventListener('mouseleave',hideTip);
    cell.onclick=()=>{selectedFilter=i;buildFilterGrid();showFilterDetail();};
    grid.appendChild(cell);
  }
  showFilterDetail();
}

function showFilterDetail() {
  const dc=document.getElementById('filterDetail');
  renderFilterCanvas(dc,selectedFilter,280,280);
  // Response
  const rc=document.getElementById('filterResponse');
  const rctx=rc.getContext('2d');
  const W=280,H=280;
  rc.width=W; rc.height=H;
  const img=rctx.createImageData(W,H);
  const r=seeded(selectedFilter*31);
  const fns=filterFns[filterStyle];
  const fn=fns[selectedFilter%fns.length];
  const phase=r()*Math.PI*2;
  const complexity=layerComplexity[filterLayer];
  for(let y=0;y<H;y++) for(let x=0;x<W;x++){
    const raw=Math.max(0,fn(x,y,W,H,phase)*complexity*0.5+r()*0.1);
    const t=clamp(raw);
    const rv=Math.round(t*235+20);
    const k=(y*W+x)*4;
    img.data[k]=rv; img.data[k+1]=Math.round(t*100); img.data[k+2]=Math.round((1-t)*200+20); img.data[k+3]=255;
  }
  rctx.putImageData(img,0,0);
}

function setFilterLayer(l,btn){
  filterLayer=l;
  document.querySelectorAll('#ch1 .ctrl-row:first-child .ctrl-btn').forEach(b=>b.classList.remove('active'));
  btn.classList.add('active'); buildFilterGrid();
}
function setFilterStyle(s,btn){
  filterStyle=s;
  document.querySelectorAll('#ch1 .ctrl-row:nth-child(2) .ctrl-btn').forEach(b=>b.classList.remove('active'));
  btn.classList.add('active'); buildFilterGrid();
}

// ══════════════════════════════════════════════════
// CHAPTER 3 — CLASS MODEL VISUALIZATION
// ══════════════════════════════════════════════════
let classReg='l2', selectedClass=0;

const classPatterns=[
  // 10 distinct patterns for each class
  (x,y,W,H,r)=>Math.sin(x/W*Math.PI*6)*Math.cos(y/H*Math.PI*6),
  (x,y,W,H,r)=>Math.sin((x+y)/(W+H)*Math.PI*10)+r()*0.3,
  (x,y,W,H,r)=>1-Math.sqrt((x/W-0.5)**2+(y/H-0.5)**2)*2.5,
  (x,y,W,H,r)=>Math.sin(x/W*Math.PI*4)*Math.sin(y/H*Math.PI*4)*Math.cos(r()*Math.PI),
  (x,y,W,H,r)=>(Math.sin(x/W*8)+Math.cos(y/H*8))/2+r()*0.2,
  (x,y,W,H,r)=>Math.abs(Math.sin(x/W*Math.PI*3+r()))*Math.abs(Math.cos(y/H*Math.PI*3)),
  (x,y,W,H,r)=>Math.sin(Math.sqrt((x-W/2)**2+(y-H/2)**2)/W*Math.PI*8),
  (x,y,W,H,r)=>Math.sin(x/W*Math.PI*5+r()*2)*Math.sin(y/H*Math.PI*5),
  (x,y,W,H,r)=>clamp(Math.sin(x/W*7+y/H*7)*0.7+r()*0.3),
  (x,y,W,H,r)=>Math.atan2(y/H-0.5, x/W-0.5)/Math.PI/2+0.5,
];

const classLabels=['Adenoca','Squamous','SmallCell','Benign','Normal','GGO','Consol.','Effusion','PTX','Emphys.'];
const classCMs=[viridis,plasma,hot,viridis,plasma,diverge,hot,viridis,plasma,hot];

function renderClassModel(cv, ci, W=80, H=80) {
  const ctx=cv.getContext('2d');
  cv.width=W; cv.height=H;
  const img=ctx.createImageData(W,H);
  const r=seeded(ci*997+W);
  const fn=classPatterns[ci];
  const cm=classCMs[ci];
  // Regularization affects smoothness
  const smooth=classReg==='tv'?0.02:classReg==='deep'?0.05:0.01;
  for(let y=0;y<H;y++) for(let x=0;x<W;x++){
    const noise=classReg==='deep'?(r()-0.5)*0.4:classReg==='tv'?0:(r()-0.5)*0.12;
    const raw=fn(x,y,W,H,r);
    const t=clamp(raw*0.5+0.5+noise);
    const [rv,gv,bv]=cm(t);
    const k=(y*W+x)*4;
    img.data[k]=rv; img.data[k+1]=gv; img.data[k+2]=bv; img.data[k+3]=255;
  }
  ctx.putImageData(img,0,0);
}

function buildClassGrid() {
  const grid=document.getElementById('classGrid');
  grid.innerHTML='';
  classLabels.forEach((name,ci)=>{
    const cell=document.createElement('div');
    cell.className='class-cell'+(ci===selectedClass?' sel':'');
    const cv=document.createElement('canvas');
    renderClassModel(cv,ci);
    const lbl=document.createElement('div');
    lbl.className='class-cell-label';
    lbl.textContent=name;
    cell.appendChild(cv); cell.appendChild(lbl);
    cell.addEventListener('mouseenter',e=>showTip(e,`Class Model: ${classLabels[ci]}`,`Gradient ascent synthesizes the "ideal" ${name} stimulus. Regularization: ${classReg}.`));
    cell.addEventListener('mouseleave',hideTip);
    cell.onclick=()=>{selectedClass=ci;buildClassGrid();showClassDetail();};
    grid.appendChild(cell);
  });
  showClassDetail();
}

function showClassDetail() {
  renderClassModel(document.getElementById('classDetail'),selectedClass,240,240);
  const sc=document.getElementById('classSpectrum');
  const sctx=sc.getContext('2d');
  const W=240,H=240; sc.width=W; sc.height=H;
  // Frequency magnitude spectrum visualization
  const img=sctx.createImageData(W,H);
  const r=seeded(selectedClass*333);
  for(let y=0;y<H;y++) for(let x=0;x<W;x++){
    const fx=(x-W/2)/W, fy=(y-H/2)/H;
    const freq=Math.sqrt(fx*fx+fy*fy);
    const spectrum=Math.exp(-freq*freq*2*(selectedClass+1))*0.8+r()*0.15;
    const t=clamp(spectrum);
    const [rv,gv,bv]=viridis(t);
    const k=(y*W+x)*4;
    img.data[k]=rv; img.data[k+1]=gv; img.data[k+2]=bv; img.data[k+3]=255;
  }
  sctx.putImageData(img,0,0);
  sctx.fillStyle='rgba(245,240,232,0.4)'; sctx.font='7px Inconsolata';
  sctx.fillText('DC', W/2+3, H/2-3);
  sctx.beginPath(); sctx.arc(W/2,H/2,3,0,Math.PI*2); sctx.fillStyle='white'; sctx.fill();

  // Octave
  const oc=document.getElementById('classOctave');
  const octx=oc.getContext('2d');
  oc.width=W; oc.height=H;
  const octaveH=H/3;
  const octaveLabels=['Low freq','Mid freq','High freq'];
  const octaveCms=[viridis,plasma,hot];
  [0,1,2].forEach(oi=>{
    const oimg=octx.createImageData(W,octaveH);
    const ro=seeded(selectedClass*111+oi*77);
    const fn=classPatterns[selectedClass];
    for(let y=0;y<octaveH;y++) for(let x=0;x<W;x++){
      const scale=1/(1<<oi);
      const raw=fn(x*scale,y*scale,W*scale,octaveH*scale,ro);
      const t=clamp(raw*0.5+0.5+(ro()-0.5)*0.05*(oi+1));
      const [rv,gv,bv]=octaveCms[oi](t);
      const k=(y*W+x)*4;
      oimg.data[k]=rv; oimg.data[k+1]=gv; oimg.data[k+2]=bv; oimg.data[k+3]=255;
    }
    octx.putImageData(oimg,0,octaveH*oi);
    octx.fillStyle='rgba(14,12,10,0.5)';
    octx.fillRect(0, oi*octaveH, 70, 12);
    octx.fillStyle='rgba(245,240,232,0.7)'; octx.font='7px Inconsolata';
    octx.fillText(octaveLabels[oi], 3, oi*octaveH+9);
  });
}

function setClassReg(reg,btn){
  classReg=reg;
  document.querySelectorAll('#ch2 .ctrl-row:first-child .ctrl-btn').forEach(b=>b.classList.remove('active'));
  btn.classList.add('active'); buildClassGrid();
}
function updateIterLabel(el){document.getElementById('iterLabel').textContent=el.value;}

// ══════════════════════════════════════════════════
// CHAPTER 4 — SALIENCY MAPS
// ══════════════════════════════════════════════════
let saliencyInput=0;

// Input patterns
function getInputData(W,H) {
  const patterns=[
    // CT nodule
    (x,y)=>{
      const cx=W/2, cy=H/2;
      const dx=(x-cx)/cx, dy=(y-cy)/cy;
      const d=Math.sqrt(dx*dx+dy*dy);
      let v=d<0.92?lerp(-100,60,(0.92-d)/0.92):-1000;
      const tx=dx-0.18, ty=dy+0.05;
      if(Math.sqrt(tx*tx+ty*ty)<0.09) v=20;
      const lx=dx+0.25; if(Math.sqrt(lx*lx*1.8+dy*dy)<0.25) v=-650;
      const rx=dx-0.25; if(Math.sqrt(rx*rx*1.8+dy*dy)<0.25) v=-650;
      return clamp((v+1000)/2000);
    },
    // Edge grid
    (x,y)=>(Math.sin(x/W*Math.PI*8)*Math.cos(y/H*Math.PI*8)+1)/2,
    // Circle
    (x,y)=>{const r=Math.sqrt((x/W-0.5)**2+(y/H-0.5)**2); return Math.max(0,1-r*4)+0.2*Math.sin(r*40);},
    // Texture
    (x,y)=>(Math.sin(x/W*60)*Math.cos(y/H*60)+1)/2,
  ];
  const fn=patterns[saliencyInput];
  const data=new Float32Array(W*H);
  for(let y=0;y<H;y++) for(let x=0;x<W;x++) data[y*W+x]=clamp(fn(x,y));
  return data;
}

function gaussian2d(data,W,H,sigma){
  if(sigma<=0) return data;
  const out=new Float32Array(W*H);
  const ks=Math.ceil(sigma*3);
  const kernel=[];
  let ksum=0;
  for(let ky=-ks;ky<=ks;ky++) for(let kx=-ks;kx<=ks;kx++){
    const v=Math.exp(-(kx*kx+ky*ky)/(2*sigma*sigma));
    kernel.push({kx,ky,v}); ksum+=v;
  }
  for(let y=0;y<H;y++) for(let x=0;x<W;x++){
    let s=0;
    kernel.forEach(({kx,ky,v})=>{
      const ix=clamp(x+kx,0,W-1), iy=clamp(y+ky,0,H-1);
      s+=data[iy*W+ix]*v;
    });
    out[y*W+x]=s/ksum;
  }
  return out;
}

function computeVanillaGrad(input,W,H){
  // Approximate: gradient of a simple "class score" function
  const grad=new Float32Array(W*H);
  for(let y=0;y<H;y++) for(let x=0;x<W;x++){
    const i=y*W+x;
    const dx=x<W-1?input[(y*W+x+1)]-input[i]:0;
    const dy=y<H-1?input[((y+1)*W+x)]-input[i]:0;
    grad[i]=Math.abs(dx)+Math.abs(dy);
  }
  return grad;
}

function computeSmoothGrad(input,W,H,sigma){
  const r=seeded(42);
  const accum=new Float32Array(W*H);
  const N=8;
  for(let n=0;n<N;n++){
    const noisy=input.map(v=>clamp(v+(r()-0.5)*0.1));
    const g=computeVanillaGrad(noisy,W,H);
    for(let i=0;i<W*H;i++) accum[i]+=g[i];
  }
  const out=accum.map(v=>v/N);
  return gaussian2d(out,W,H,sigma);
}

function computeGradInput(input,W,H){
  const g=computeVanillaGrad(input,W,H);
  return g.map((v,i)=>v*input[i]);
}

function computeGradCAM(input,W,H){
  // Simulate GradCAM: blur + weight by class relevance
  const blurred=gaussian2d(input,W,H,4);
  const cam=new Float32Array(W*H);
  const cx=W/2, cy=H/2;
  for(let y=0;y<H;y++) for(let x=0;x<W;x++){
    const i=y*W+x;
    // Class-discriminative weighting: peak at tumor/feature region
    const dist=Math.sqrt((x/W-0.5+0.18)**2+(y/H-0.5-0.05)**2);
    const weight=Math.exp(-dist*dist*8)*0.8+blurred[i]*0.2;
    cam[i]=Math.max(0,weight);
  }
  return gaussian2d(cam,W,H,6);
}

function normalize(data){
  let mn=Infinity, mx=-Infinity;
  data.forEach(v=>{if(v<mn)mn=v;if(v>mx)mx=v;});
  const range=mx-mn||1;
  return data.map(v=>(v-mn)/range);
}

function renderSaliency(c, smap, overlay, alpha_01) {
  const ctx=c.getContext('2d');
  const W=c.width, H=c.height;
  const img=ctx.createImageData(W,H);
  for(let y=0;y<H;y++) for(let x=0;x<W;x++){
    const i=y*W+x;
    const base=Math.round(overlay[i]*200+20);
    const t=smap[i];
    const [hr,hg,hb]=plasma(t);
    const a=t*alpha_01;
    const k=i*4;
    img.data[k]=Math.round(lerp(base,hr,a));
    img.data[k+1]=Math.round(lerp(base,hg,a));
    img.data[k+2]=Math.round(lerp(base,hb,a));
    img.data[k+3]=255;
  }
  ctx.putImageData(img,0,0);
}

function redrawSaliency() {
  const W=180,H=180;
  const alpha=+document.getElementById('saliencyAlpha').value/100;
  const sigma=+document.getElementById('saliencySigma').value;
  const input=getInputData(W,H);
  const methods=[
    computeVanillaGrad(input,W,H),
    computeSmoothGrad(input,W,H,sigma),
    computeGradInput(input,W,H),
    computeGradCAM(input,W,H),
  ];
  const labels=['Vanilla Grad','SmoothGrad','Grad × Input','GradCAM'];
  const ids=['sal0','sal1','sal2','sal3'];
  methods.forEach((m,i)=>{
    const smap=normalize(m);
    const overlay=normalize(input);
    const c=document.getElementById(ids[i]);
    c.width=W; c.height=H;
    renderSaliency(c,smap,overlay,alpha);
  });

  // Also draw top row comparison
  buildSaliencyRow(input,methods,labels,alpha);
}

function buildSaliencyRow(input,methods,labels,alpha){
  const row=document.getElementById('saliencyRow');
  row.innerHTML='';
  methods.forEach((m,i)=>{
    const wrap=document.createElement('div');
    wrap.className='canvas-box';
    wrap.style.position='relative';
    const tag=document.createElement('div');
    tag.className='canvas-tag';
    tag.textContent=labels[i];
    const cv=document.createElement('canvas');
    cv.width=160; cv.height=160;
    const smap=normalize(m);
    const overlay=normalize(input);
    renderSaliency(cv,smap,overlay,alpha);
    wrap.appendChild(tag); wrap.appendChild(cv);
    wrap.addEventListener('mouseenter',e=>showTip(e,labels[i],['∂S_c/∂x — fast but noisy','Average over noisy inputs','x ⊙ ∂S_c/∂x — sharp','Weighted feature map sum'][i]));
    wrap.addEventListener('mouseleave',hideTip);
    row.appendChild(wrap);
  });
}

function selectSaliencyInput(idx, btn) {
  saliencyInput=idx;
  document.querySelectorAll('#ch3 .ctrl-row:first-child .ctrl-btn').forEach(b=>b.classList.remove('active'));
  btn.classList.add('active');
  redrawSaliency();
}

// ══════════════════════════════════════════════════
// INIT
// ══════════════════════════════════════════════════
window.addEventListener('load', ()=>{
  // Ch1 — Latent
  latentPoints=genLatentPoints();
  buildClassPills();
  buildInterpSelects();
  drawLatentScatter();
  drawInterp();

  // Ch2 — Filters
  buildFilterGrid();

  // Ch3 — Class models
  buildClassGrid();

  // Ch4 — Saliency
  redrawSaliency();
});
</script>
</body>
</html>
